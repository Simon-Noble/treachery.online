@*
 * Copyright (C) 2020-2024 Ronald Ossendrijver (admin@treachery.online)
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This
 * program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have
 * received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>.
*@
@inherits MapComponent

@if (h.Game.CurrentPhase >= Phase.MetheorAndStormSpell)
{
    var y = 1.75f * Skin.Current.FORCETOKEN_RADIUS;
    var x = 1.5f * Skin.Current.FORCETOKEN_RADIUS;
    var leaderDiameter = 3.2f * Skin.Current.FORCETOKEN_RADIUS;
    var leaderPctHeight = .25f * leaderDiameter * Skin.Current.BattleWheelHeroHeight / Skin.Current.BattleWheelHeroWidth;
    var spacing = 0.85f;

    foreach (var p in h.Game.Players)
    {
        var color = Skin.Current.GetFactionColor(p.Faction);

        if (p.ForcesKilled > 0 || p.SpecialForcesKilled > 0)
        {
            if (p.ForcesKilled > 0)
            {
                <MapForce X=@x Y=@y Special=@false Amount=@p.ForcesKilled Faction=@p.Faction />
            }

            if (p.SpecialForcesKilled > 0)
            {
                var dX = p.ForcesKilled > 0 ? 2 * Skin.Current.FORCETOKEN_RADIUS : 0;
                <MapForce X=@(x + dX) Y=@y Special=@true Amount=@p.SpecialForcesKilled Faction=@p.Faction />
            }

            y += spacing * 2 * Skin.Current.FORCETOKEN_RADIUS;
        }

        var corpses = p.Leaders
            .Where(l => !h.Game.IsAlive(l))
            .Select(l => new Tuple<Leader, LeaderState>(l, h.Game.LeaderState[l]))
            .OrderBy(l => l.Item2.TimeOfDeath).Select(l => l.Item1);

        var corpseNr = 0;
        if (corpses.Any())
        {
            y += spacing * (leaderPctHeight * (corpses.Count() - 1));
            var dy = 0;
            var displaceX = (int)(0.2f * leaderDiameter);
            foreach (var leader in corpses)
            {
                var l = new PointD(x, y - dy);

                if (h.Game.LeaderState[leader].IsFaceDownDead)
                {
                    <MapImage X="@(l.X + displaceX)" Y="@(l.Y)" Diameter="@(leaderDiameter)"
                           Src="@Skin.Current.GetFactionFacedownImageURL(p.Faction)"
                           Popover="@Popover(leader)" PopoverStyle=""
                           ShadowColor="@Skin.Current.SHADOW" ShadowX="2" ShadowY="2" ShadowBlur="1" />
                }
                else
                {
                    <MapLeader h="h" ToShow="leader" X=@(l.X + displaceX) Y=@(l.Y) Diameter="leaderDiameter"/>
                }

                displaceX *= -1;
                dy += (int)leaderPctHeight;
                corpseNr++;
            }

            y += spacing * leaderDiameter;
        }

        if (p.Faction == Faction.Green && !h.Game.MessiahIsAlive)
        {
            var l = new PointD(x, y);
            <MapImage X="@(x)" Y="@(y)" Diameter="@(0.5f * leaderDiameter)"
                   Src="@Skin.Current.Messiah_URL"
                   ShadowColor="@Skin.Current.SHADOW" ShadowX="2" ShadowY="2" ShadowBlur="1" Popover="@Skin.Current.Describe(Concept.Messiah)"/>
            
            y += spacing * leaderDiameter;
        }

        NextColumnIfNecessary(ref y, ref x, spacing);
    }
}

@code {
        
    private Situation situation = new();
    protected override bool ShouldRender()
    {
        return situation.RequiresUpdate(Game);
    }

    private static void NextColumnIfNecessary(ref float y, ref float x, float spacing)
    {
        if (y > 15 * Skin.Current.FORCETOKEN_RADIUS - 0.8f * x)
        {
            y = 1.75f * Skin.Current.FORCETOKEN_RADIUS;
            x += 4.25f * Skin.Current.FORCETOKEN_RADIUS;
        }
    }

    private string Popover(Leader l)
    {
        return Player.Is(l.Faction) || Player.Is(Faction.Purple) ? Popup.Get(l, Game) : "?";
    }

}
