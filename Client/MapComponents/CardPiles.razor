@using Treachery.Shared
@inherits MapComponent

@{

    int cardWidth = Skin.Current.CardSize.X;
    int cardHeight = Skin.Current.CardSize.Y;

    var x = Skin.Current.SpiceDeckLocation.X;
    var y = Skin.Current.SpiceDeckLocation.Y;

    //Resource cards
    string cardImageToShow = Game.CurrentMainPhase == MainPhase.ShipmentAndMove && Game.HasResourceDeckPrescience(h.Player) ? Skin.Current.GetImageURL(Game.ResourceCardDeck.Top) : Skin.Current.CardBack_ResourceCard_URL;
    <Image X="@(x)" Y="@(y)" Width=@(cardWidth) Height="@(cardHeight)" Src="@cardImageToShow" 
           ShadowColor="@Skin.Current.SHADOW" ShadowX="2" ShadowY="2" ShadowBlur="2" 
           Popover="@IntelOfResourceCardPile()"/>
 
    <MapText ToShow="@Game.ResourceCardDeck.Items.Count.ToString()"
             X="@(x + cardWidth / 2)" Y="@(y + cardHeight / 1.5f)"
             Font="@Skin.Current.CARDPILE_FONT" FontColor="@Skin.Current.CARDPILE_FONTCOLOR"
             BorderWidth="@Skin.Current.CARDPILE_FONT_BORDERWIDTH" BorderColor="@Skin.Current.CARDPILE_FONT_BORDERCOLOR"
             Align="@TextAlignment.Center" />

    x += cardWidth + (int)(0.1f * cardWidth);
    if (Game.LatestSpiceCardA != null)
    {
        <Image X="@(x)" Y="@(y)" Width=@(cardWidth) Height="@(cardHeight)" Src="@Skin.Current.GetImageURL(Game.LatestSpiceCardA)" 
               ShadowColor="@Skin.Current.SHADOW" ShadowX="2" ShadowY="2" ShadowBlur="1" 
               Popover="@IntelOfResourceDiscardPileA()"/>
    }

    if (Game.Applicable(Rule.IncreasedResourceFlow))
    {
        <MapText ToShow="A"
                 X="@(x + cardWidth / 2)" Y="@(y + cardHeight / 1.5f)"
                 Font="@Skin.Current.CARDPILE_FONT" FontColor="@Skin.Current.CARDPILE_FONTCOLOR"
                 BorderWidth="@Skin.Current.CARDPILE_FONT_BORDERWIDTH" BorderColor="@Skin.Current.CARDPILE_FONT_BORDERCOLOR"
                 Align="@TextAlignment.Center" />

        x += cardWidth + (int)(0.1f * cardWidth);
        if (Game.LatestSpiceCardB != null)
        {
            <Image X="@(x)" Y="@(y)" Width=@(cardWidth) Height="@(cardHeight)" Src="@Skin.Current.GetImageURL(Game.LatestSpiceCardB)" 
                   ShadowColor="@Skin.Current.SHADOW" ShadowX="2" ShadowY="2" ShadowBlur="1" 
                   Popover="@IntelOfResourceDiscardPileB()"/>
        }

        <MapText ToShow="B"
                 X="@(x + cardWidth / 2)" Y="@(y + cardHeight / 1.5f)"
                 Font="@Skin.Current.CARDPILE_FONT" FontColor="@Skin.Current.CARDPILE_FONTCOLOR"
                 BorderWidth="@Skin.Current.CARDPILE_FONT_BORDERWIDTH" BorderColor="@Skin.Current.CARDPILE_FONT_BORDERCOLOR"
                 Align="@TextAlignment.Center" />
    }

    //Treachery cards
    x = Skin.Current.TreacheryDeckLocation.X;

    if (Game.TreacheryDeck.Items.Count > 0)
    {
        <Image X="@(x)" Y="@(Skin.Current.TreacheryDeckLocation.Y)" Width=@(cardWidth) Height="@(cardHeight)" Src="@Skin.Current.CardBack_TreacheryCard_URL" 
               ShadowColor="@Skin.Current.SHADOW" ShadowX="2" ShadowY="2" ShadowBlur="1" 
               Popover="@IntelOfTreacheryCardPile()"/>
    }

    <MapText ToShow="@Game.TreacheryDeck.Items.Count.ToString()"
             X="@(x + cardWidth / 2)" Y="@(Skin.Current.TreacheryDeckLocation.Y + cardHeight / 1.5f)"
             Font="@Skin.Current.CARDPILE_FONT" FontColor="@Skin.Current.CARDPILE_FONTCOLOR"
             BorderWidth="@Skin.Current.CARDPILE_FONT_BORDERWIDTH" BorderColor="@Skin.Current.CARDPILE_FONT_BORDERCOLOR"
             Align="@TextAlignment.Center" />

    if (!Game.TreacheryDiscardPile.IsEmpty)
    {
        x += cardWidth + (int)(0.1f * cardWidth);
        <Image X="@(x)" Y="@(Skin.Current.TreacheryDeckLocation.Y)" Width=@(cardWidth) Height="@(cardHeight)" Src="@Skin.Current.GetImageURL(Game.TreacheryDiscardPile.Top)" 
               ShadowColor="@Skin.Current.SHADOW" ShadowX="2" ShadowY="2" ShadowBlur="1" 
               Popover="@IntelOfTreacheryDiscardPile()"/>

        <MapText ToShow="@Game.TreacheryDiscardPile.Items.Count.ToString()"
                 X="@(x + cardWidth / 2)" Y="@(Skin.Current.TreacheryDeckLocation.Y + cardHeight / 1.5f)"
                 Font="@Skin.Current.CARDPILE_FONT" FontColor="@Skin.Current.CARDPILE_FONTCOLOR"
                 BorderWidth="@Skin.Current.CARDPILE_FONT_BORDERWIDTH" BorderColor="@Skin.Current.CARDPILE_FONT_BORDERCOLOR"
                 Align="@TextAlignment.Center" />
    }

    if (Game.WhiteCache.Count > 0)
    {
        x = Skin.Current.TreacheryDeckLocation.X - (int)(1.1f * cardWidth);

        <Image X="@(x)" Y="@(Skin.Current.TreacheryDeckLocation.Y)" Width=@(cardWidth) Height="@(cardHeight)" Src="@Skin.Current.CardBack_TreacheryCard_URL" 
               ShadowColor="@Skin.Current.SHADOW" ShadowX="2" ShadowY="2" ShadowBlur="1" 
               Popover="@IntelOfWhiteCardPile()"/>

        <Image X="@(x + cardWidth / 3)" Y="@(Skin.Current.TreacheryDeckLocation.Y + cardHeight / 8)" Diameter="@(cardWidth / 3)" Src="@Skin.Current.GetImageURL(Faction.White)" ShadowColor="@Skin.Current.SHADOW" ShadowX="1" ShadowY="1" ShadowBlur="0" />

        <MapText ToShow="@Game.WhiteCache.Count.ToString()"
                 X="@(x + cardWidth / 2)" Y="@(Skin.Current.TreacheryDeckLocation.Y + cardHeight / 1.5f)"
                 Font="@Skin.Current.CARDPILE_FONT" FontColor="@Skin.Current.CARDPILE_FONTCOLOR"
                 BorderWidth="@Skin.Current.CARDPILE_FONT_BORDERWIDTH" BorderColor="@Skin.Current.CARDPILE_FONT_BORDERCOLOR"
                 Align="@TextAlignment.Center" />
    }
}

@code {

    private string IntelOfTreacheryCardPile()
    {
        return Skin.Current.Format("<h4>Treachery Cards: {0} on deck</h4>", h.Game.TreacheryDeck.Items.Count); ;
    }

    private string IntelOfTreacheryDiscardPile()
    {
        string result = "";

        result += Skin.Current.Format("<h4>Discard pile: {0} cards</h4>", h.Game.TreacheryDiscardPile.Items.Count);

        if (h.Game.Applicable(Rule.AssistedNotekeeping))
        {
            result += "<div class=\"row row-cols-6 ml-0 mr-0 mt-1\">";
            foreach (var c in h.Game.TreacheryDiscardPile.Items)
            {
                result += string.Format("<img src=\"{0}\" class=\"img-fluid\"/>", Skin.Current.GetImageURL(c));
            }
            result += "</div>";
        }
        else if (h.Game.TreacheryDiscardPile.Top != null)
        {
            result += "Most recently discarded:";
            result += Support.GetTreacheryCardHoverHTML(h.Game.TreacheryDiscardPile.Top);
        }

        return result;
    }

    private string IntelOfWhiteCardPile()
    {
        string result = "";
        if (h.Game.WhiteCache.Count > 0)
        {
            result += Skin.Current.Format("<h4>{0} cards: {1} on deck</h4>", Faction.White, h.Game.WhiteCache.Count);

            if (h.Faction == Faction.White || h.Game.Applicable(Rule.AssistedNotekeeping))
            {
                result += "<div class=\"row row-cols-6 ml-0 mr-0 mt-1\">";
                foreach (var c in h.Game.WhiteCache)
                {
                    result += string.Format("<img src=\"{0}\" class=\"img-fluid\"/>", Skin.Current.GetImageURL(c));
                }
                result += "</div>";
            }
        }

        return result;
    }

    private string IntelOfResourceCardPile()
    {
        string result = "";

        result += Skin.Current.Format("<h4>{0} Cards: {1} on deck</h4>", Concept.Resource, h.Game.ResourceCardDeck.Items.Count);

        if (h.Game.CurrentMainPhase == MainPhase.ShipmentAndMove && h.Game.HasResourceDeckPrescience(h.Player) && h.Game.ResourceCardDeck.Top != null)
        {
            result += "<p>Top Card:</p>";
            result += Support.GetResourceCardHoverHTML(h.Game.ResourceCardDeck.Top);
        }

        return result;
    }

    private string IntelOfResourceDiscardPileA()
    {
        string result = "";

        if (h.Game.Applicable(Rule.IncreasedResourceFlow))
        {
            result += Skin.Current.Format("<h4>Discard pile A: {0} cards</h4>", h.Game.ResourceCardDiscardPileA.Items.Count);
            if (h.Game.LatestSpiceCardA != null)
            {
                result += "<p>Latest card:</p>";
                result += Support.GetResourceCardHoverHTML(h.Game.LatestSpiceCardA);
                if (h.Game.Applicable(Rule.AssistedNotekeeping))
                {
                    result += "<p>" + Skin.Current.Join(h.Game.ResourceCardDiscardPileA.Items.Where(c => c != h.Game.LatestSpiceCardA)) + "</p>";
                }
            }
        }
        else
        {
            result += Skin.Current.Format("<h4>Discard pile: {0} cards</h4>", h.Game.ResourceCardDiscardPileA.Items.Count);
            if (h.Game.LatestSpiceCardA != null)
            {
                result += "<p>Latest card:</p>";
                result += Support.GetResourceCardHoverHTML(h.Game.LatestSpiceCardA);
                if (h.Game.Applicable(Rule.AssistedNotekeeping))
                {
                    result += "<p>" + Skin.Current.Join(h.Game.ResourceCardDiscardPileB.Items.Where(c => c != h.Game.LatestSpiceCardA)) + "</p>";
                }
            }
        }

        return result;
    }

    private string IntelOfResourceDiscardPileB()
    {
        string result = "";

        if (h.Game.Applicable(Rule.IncreasedResourceFlow))
        {
            result += Skin.Current.Format("<h4>Discard pile B: {0} cards</h4>", h.Game.ResourceCardDiscardPileB.Items.Count);
            if (h.Game.LatestSpiceCardB != null)
            {
                result += "<p>Latest card:</p>";
                result += Support.GetResourceCardHoverHTML(h.Game.LatestSpiceCardB);
                if (h.Game.Applicable(Rule.AssistedNotekeeping))
                {
                    foreach (var c in h.Game.ResourceCardDiscardPileB.Items.Where(c => c != h.Game.LatestSpiceCardB))
                    {
                        result += "<p>" + c.ToString() + "</p>";
                    }
                }
            }
        }

        return result;
    }

}