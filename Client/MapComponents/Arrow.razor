<!--
 * Copyright 2020-2022 Ronald Ossendrijver. All rights reserved.
--->

@using Treachery.Shared
@using System.Linq
@inherits MapComponent
 
<defs>
    <linearGradient id="@ArrowGradientId" x1="60%" y1="60%" x2="80%" y2="80%">
        <stop offset="0%" stop-color="@FillColor"></stop>
        <stop offset="100%" stop-color="black"></stop>
    </linearGradient>
    <filter id="@ArrowShadowId" xmlns="http://www.w3.org/2000/svg" height="200%" width="200%">
        <feGaussianBlur in="SourceAlpha" stdDeviation="@(ShadowBlur)" />
        <feOffset dx="@(ShadowDistance)" dy="@(ShadowDistance)" result="offsetblur" />
        <feComponentTransfer>
            <feFuncA type="linear" slope="0.5"></feFuncA>
        </feComponentTransfer>
        <feMerge>
            <feMergeNode />
            <feMergeNode in="SourceGraphic"></feMergeNode>
        </feMerge>
    </filter>
    <path id="@ArrowTemplateId" d="M-50,-50L0,0L-50,50L0,100L100,0L0,-100L-50,-50Z" stroke="@StrokeColor" stroke-width="@Round(StrokeWidth)" stroke-linejoin="round" transform="scale(@Round(ArrowScale))" />
</defs>

@for (float i = 1; i <= n; i++)
{
    var t = -tMax * (i / n);
    var t2 = -tMax * ((i + 1) / n);
    var x = Radius * (u[0] * Math.Cos(t) + v[0] * Math.Sin(t));
    var y = Radius * (u[1] * Math.Cos(t) + v[1] * Math.Sin(t));
    var x2 = Radius * (u[0] * Math.Cos(t2) + v[0] * Math.Sin(t2));
    var y2 = Radius * (u[1] * Math.Cos(t2) + v[1] * Math.Sin(t2));
    var alpha = -Math.Atan2((x2 - x), (y2 - y)) / Math.PI * 180 + 90;

    <g transform="translate(@Round(x + Radius),@Round(y + Radius)) rotate(@Round(alpha))" fill="url(#@ArrowGradientId)" filter="url(#@ArrowShadowId)">
        <use href="#@ArrowTemplateId" />
    </g>
}

@code {

    [Parameter]
    public float MarginX { get; set; }

    [Parameter]
    public float MarginY { get; set; }

    [Parameter]
    public float Radius { get; set; }

    [Parameter]
    public Point From { get; set; }

    [Parameter]
    public Point To { get; set; }

    [Parameter]
    public float ArrowScale { get; set; } = 0.3f;

    [Parameter]
    public int ShadowDistance { get; set; } = 4;

    [Parameter]
    public int ShadowBlur { get; set; } = 1;

    [Parameter]
    public string FillColor { get; set; } = "white";

    [Parameter]
    public float FillOpacity { get; set; } = 1f;

    [Parameter]
    public string StrokeColor { get; set; } = "black";

    [Parameter]
    public float StrokeWidth { get; set; } = 0;

    private float[] u;
    private float[] v;
    private float tMax;
    private int n;

    protected override void OnParametersSet()
    {
        float fromX;
        float fromY;
        float fromZ;
        float[] fromAsArray;

        float toX;
        float toY;
        float toZ;
        float[] toAsArray;

        float[] w;

        fromX = From.X - MarginX - Radius;
        fromY = From.Y - MarginY - Radius;
        fromZ = (int)Math.Pow(Radius * Radius - fromX * fromX - fromY * fromY, 0.5);
        fromAsArray = new float[] { fromX, fromY, fromZ };

        toX = To.X - MarginX - Radius;
        toY = To.Y - MarginY - Radius;
        toZ = (int)Math.Pow(Radius * Radius - toX * toX - toY * toY, 0.5);
        toAsArray = new float[] { toX, toY, toZ };

        u = fromAsArray.Select(a => a / Radius).ToArray();
        w = cross(fromAsArray, toAsArray);
        v = cross(u, w).Select(a => a / length(w)).ToArray();
        tMax = (float)Math.Acos(inner(fromAsArray, toAsArray) / length(fromAsArray) / length(toAsArray));
        n = (int)Math.Round((50f * tMax) / Math.PI);
    }

    private float[] cross(float[] a, float[] b) => new float[] {
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0]
    };

    private float inner(float[] v1, float[] v2)
    {
        if (v1.Length != v2.Length) return float.NaN;
        return v1.Zip(v2, (x, y) => x * y).Sum();
    }

    private float length(float[] vector) => (float)Math.Sqrt(vector.Select(v => v * v).Sum());

    private string ArrowTemplateId => "arrowtemplate" + Id;
    private string ArrowShadowId => "arrowshadow" + Id;
    private string ArrowGradientId => "arrowgradient" + Id;
}
