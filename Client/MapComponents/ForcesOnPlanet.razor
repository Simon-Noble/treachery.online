<!--
* Copyright 2020-2023 Ronald Ossendrijver. All rights reserved.
--->

@using Treachery.Shared
@inherits MapComponent

@{
    foreach (var stronghold in h.Game.Map.Strongholds)
    {
        var center = Skin.Current.GetCenter(stronghold);
        var x = center.X - 2 * Skin.Current.PlayerTokenRadius;
        var y = center.Y - 0.8f * Skin.Current.PlayerTokenRadius;

        if (h.Game.StrongholdOwnership.TryGetValue(stronghold, out var owner))
        {
            var opacity = stronghold == Game.Map.HiddenMobileStronghold && !showHMS ? 0.2f : 0.8f;
            <Image X=x Y=y Diameter=@Skin.Current.PlayerTokenRadius Src="@Skin.Current.GetFactionTableImageURL(h.Game.StrongholdOwnership[stronghold])"
               Opacity=opacity Popover=@Popup.Get(stronghold.Advantage, owner) />

            y += Skin.Current.PlayerTokenRadius;
        }

        foreach (var terr in Game.TerrorIn(stronghold.Territory))
        {
            var popover = Player.Faction == Faction.Cyan ? Skin.Current.Format("{0} - {1}", terr, Skin.Current.GetTerrorTypeDescription(terr)) : "Terror";
            <Image X=x Y=y Filter="hue-rotate(180deg);" Diameter=@Skin.Current.PlayerTokenRadius Src=@Skin.Current.GetFactionTableImageURL(Faction.Cyan)
                ShadowColor="@Skin.Current.SHADOW" ShadowX="1" ShadowY="1" ShadowBlur="0" Popover=@popover />

            y += Skin.Current.PlayerTokenRadius;
        }

        var ambassador = Game.AmbassadorIn(stronghold.Territory);
        if (ambassador != Ambassador.None)
        {
            var popover = $"{Skin.Current.Describe(ambassador)} Ambassador - {Skin.Current.GetAmbassadorDescription(ambassador)}";
            <Image X=x Y=y Diameter=@Skin.Current.PlayerTokenRadius Src=@Skin.Current.GetImageURL(ambassador)
                ShadowColor="@Skin.Current.SHADOW" ShadowX="1" ShadowY="1" ShadowBlur="0" Popover=@popover />

            y += Skin.Current.PlayerTokenRadius;
        }

    }

    var forceLocations = Game.ForcesOnPlanetExcludingEmptyLocations(false);

    foreach (var location in Game.Map.Locations(false).Where(l => l.Visible).OrderBy(l => Skin.Current.GetCenter(l).Y))
    {
        var pos = Skin.Current.GetCenter(location);
        bool showForces = forceLocations.ContainsKey(location);
        float forceDiameter = 2 * Skin.Current.FORCETOKEN_RADIUS;

        if (location is HiddenMobileStronghold hms)
        {
            if (!showHMS) showForces = false;
            forceDiameter = 1.5f * Skin.Current.FORCETOKEN_RADIUS;

            <Image X="@(pos.X - 0.7f * Skin.Current.HmsRadius)"
               Y="@(pos.Y - Skin.Current.HmsRadius)"
               Width=@(Skin.Current.HmsRadius + Math.Abs(Skin.Current.HmsDX)) Height="@(2 * Skin.Current.HmsRadius)"
               Src="@Skin.Current.HMS_URL"
               ShadowColor="@Skin.Current.SHADOW" ShadowX="5" ShadowY="5" ShadowBlur="1"
               Opacity="@(showHMS ? 1f : 0.3f)"
               Popover="@Intel(location)"
               OnClick="@(e => OnClick(e, location))" />

            @if (showHMS && h.Status.HighlightedTerritories.Contains(location.Territory))
            {
                <Circle X="(pos.X + 0.3f * Skin.Current.HmsRadius)" Y="pos.Y" Radius="(0.85f * Skin.Current.HmsRadius)"
                    FillColor="@Skin.Current.HIGHLIGHT_OVERLAY_COLOR" FillOpacity="1" StrokeColor="red" StrokeWidth="1" />
            }

            <Image X="@(pos.X - 0.4f * Skin.Current.HmsRadius + Math.Abs(Skin.Current.HmsDX))"
               Y="@(pos.Y - 0.18f * Skin.Current.HmsRadius)"
               Diameter="@(Skin.Current.FORCETOKEN_RADIUS)"
               Src="@(showHMS ? Skin.Current.Eye_URL : Skin.Current.EyeSlash_URL)"
               ShadowColor="black" ShadowX="1" ShadowY="1" ShadowBlur="0"
               OnClick="OnShowHmsClick"
               Title="@(showHMS ? "Hide HMS" : "Show HMS")" />
        }
        else if (location is DiscoveredLocation ds)
        {
            forceDiameter = 1.5f * Skin.Current.FORCETOKEN_RADIUS;

            <Image X=@(pos.X - 1.5f * Skin.Current.FORCETOKEN_RADIUS) Y=@(pos.Y - 2f * Skin.Current.FORCETOKEN_RADIUS) Diameter=@(3 * Skin.Current.FORCETOKEN_RADIUS) 
                Src=@Skin.Current.GetImageURL(ds.Discovery) Popover=@Intel(ds)
                ShadowX=1 ShadowY=1 />

            @if (h.Status.HighlightedTerritories.Contains(location.Territory))
            {
                <Circle X="(pos.X)" Y=@(pos.Y - 0.5f * Skin.Current.FORCETOKEN_RADIUS) Radius="(1.5f * Skin.Current.FORCETOKEN_RADIUS)"
                    FillColor="@Skin.Current.HIGHLIGHT_OVERLAY_COLOR" FillOpacity="1" StrokeColor="red" StrokeWidth="1" />
            }
        }
        else if (Game.DiscoveriesOnPlanet.TryGetValue(location, out var discovery))
        {
            string popoverToShow =
                (Player.Faction == Faction.Yellow && discovery.TokenType == DiscoveryTokenType.Yellow || Player.Faction == Faction.Orange && discovery.TokenType == DiscoveryTokenType.Orange) ?
                $"{Skin.Current.Describe(discovery.Token)} - {Skin.Current.GetDiscoveryTokenDescription(discovery.Token)}" : Skin.Current.Describe(discovery.TokenType);

            <Image X=@(pos.X - 3 * Skin.Current.FORCETOKEN_RADIUS) Y=@(pos.Y - 3 * Skin.Current.FORCETOKEN_RADIUS) Diameter=@(2 * Skin.Current.FORCETOKEN_RADIUS)
               Src=@Skin.Current.GetImageURL(discovery.TokenType) Popover=@popoverToShow
                Opacity="0.9f" ShadowX=1 ShadowY=1 />
        }

        if (showForces)
        {
            <ForcesInLocation h=@h Location=@location Battalions=@forceLocations Diameter=@forceDiameter />
        }
    }
}

@code {

    private Situation situation = new();
    protected override bool ShouldRender() => CheckAndResetDirty() || situation.RequiresUpdate(Game);

    private bool showHMS = true;
    private bool dirty = false;

    [Parameter]
    public EventCallback<LocationEventArgs> OnLocationClick { get; set; }

    private async Task OnClick(MouseEventArgs e, Location l)
    {
        await OnLocationClick.InvokeAsync(new LocationEventArgs() { Location = l, AltKey = e.AltKey, CtrlKey = e.CtrlKey, ShiftKey = e.ShiftKey });
    }

    private bool CheckAndResetDirty()
    {
        bool result = dirty;
        dirty = false;
        return result;
    }

    private void OnShowHmsClick(MouseEventArgs e)
    {
        showHMS = !showHMS;
        dirty = true;
        StateHasChanged();
    }
}