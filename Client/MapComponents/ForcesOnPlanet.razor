<!--
* Copyright 2020-2023 Ronald Ossendrijver. All rights reserved.
--->

@using Treachery.Shared
@inherits MapComponent

@{
    foreach (var stronghold in h.Game.Map.Strongholds)
    {
        var center = Skin.Current.GetCenter(stronghold);
        var x = center.X - 2 * Skin.Current.PlayerTokenRadius;
        var y = center.Y - 0.8f * Skin.Current.PlayerTokenRadius;

        if (h.Game.StrongholdOwnership.ContainsKey(stronghold))
        {
            var opacity = stronghold == Game.Map.HiddenMobileStronghold && !showHMS ? 0.2f : 0.8f;
            <Image X=x Y=y Diameter=@Skin.Current.PlayerTokenRadius Src="@Skin.Current.GetFactionTableImageURL(h.Game.StrongholdOwnership[stronghold])"
               Opacity=opacity Popover=@Popup.Get(stronghold, Game.StrongholdOwnership[stronghold]) />

            y += Skin.Current.PlayerTokenRadius;
        }

        foreach (var terr in Game.TerrorIn(stronghold.Territory))
        {
            var popover = Player.Faction == Faction.Cyan ? Skin.Current.Describe(terr) : "Terror";
            <Image X=x Y=y Filter="hue-rotate(180deg);" Diameter=@Skin.Current.PlayerTokenRadius Src=@Skin.Current.GetFactionTableImageURL(Faction.Cyan)
               ShadowColor="@Skin.Current.SHADOW" ShadowX="1" ShadowY="1" ShadowBlur="0" Popover=@popover />

            y += Skin.Current.PlayerTokenRadius;
        }

        var ambassador = Game.AmbassadorIn(stronghold.Territory);
        if (ambassador != Faction.None)
        {
            var popover = Player.Faction == Faction.Pink ? Skin.Current.Describe(ambassador) : "Ambassador";
            <Image X=x Y=y Filter="hue-rotate(180deg);" Diameter=@Skin.Current.PlayerTokenRadius Src=@Skin.Current.GetFactionTableImageURL(Faction.Pink)
               ShadowColor="@Skin.Current.SHADOW" ShadowX="1" ShadowY="1" ShadowBlur="0" Popover=@popover />

            y += Skin.Current.PlayerTokenRadius;
        }

    }

    var forceLocations = Game.ForcesOnPlanetExcludingEmptyLocations(false);

    foreach (var location in Game.Map.Locations(false).Where(l => l != Game.Map.HiddenMobileStronghold && l is not Homeworld).OrderBy(l => Skin.Current.GetCenter(l).Y))
    {
        int xOffset = 0;
        int yOffset = 0;
        var pos = Skin.Current.GetCenter(location);

        if (forceLocations.ContainsKey(location))
        {
            var battalions = forceLocations[location];
            int nrOfBattalions = battalions.Count;
            yOffset = -(nrOfBattalions - 1) * Skin.Current.FORCETOKEN_RADIUS;

            foreach (var battalion in battalions)
            {
                var player = Game.GetPlayer(battalion.Faction);
                var threatened = Game.ThreatenedByAllyPresence(player, location.Territory);

                xOffset = 0;
                if (battalion.AmountOfForces > 0)
                {
                    <MapForce X=@pos.X Y=@(yOffset + pos.Y) Special=@false Amount=@battalion.AmountOfForces Faction=@battalion.Faction Threatened=@threatened ShowPopover="false"/>
                    xOffset += 2 * Skin.Current.FORCETOKEN_RADIUS;
                }

                if (battalion.AmountOfSpecialForces > 0)
                {
                    <MapForce X=@(pos.X + xOffset) Y=@(yOffset + pos.Y) Special=@true Amount=@battalion.AmountOfSpecialForces Faction=@battalion.Faction Threatened=@threatened ShowPopover="false"/>
                    xOffset += 2 * Skin.Current.FORCETOKEN_RADIUS;
                }

                yOffset += 2 * Skin.Current.FORCETOKEN_RADIUS;
            }
        }

        if (Game.AnyForcesIn(location.Territory) ? forceLocations.ContainsKey(location) : location == location.Territory.MiddleLocation)
        {
            xOffset = 0;
            foreach (var hero in Game.LeaderState.Where(state => state.Key is IHero && state.Value.Alive && state.Value.CurrentTerritory == location.Territory).Select(state => state.Key))
            {
                <MapLeader h="h" ToShow="hero" X=@(pos.X + xOffset - Skin.Current.FORCETOKEN_RADIUS) Y=@(yOffset + pos.Y - Skin.Current.FORCETOKEN_RADIUS) Diameter="@(3 * Skin.Current.FORCETOKEN_RADIUS)"/>
                xOffset += 3 * Skin.Current.FORCETOKEN_RADIUS;
            }
        }
    }

    if (h.Game.Map.HiddenMobileStronghold.Visible)
    {
        var hmsCenter = Skin.Current.GetCenter(h.Game.Map.HiddenMobileStronghold);

        <Image X="@(hmsCenter.X - 0.7f * Skin.Current.HmsRadius)"
               Y="@(hmsCenter.Y - Skin.Current.HmsRadius)"
               Width=@(Skin.Current.HmsRadius + Math.Abs(Skin.Current.HmsDX)) Height="@(2 * Skin.Current.HmsRadius)"
               Src="@Skin.Current.HMS_URL"
               ShadowColor="@Skin.Current.SHADOW" ShadowX="5" ShadowY="5" ShadowBlur="1"
               Opacity="@(showHMS ? 1f : 0.3f)"
               Popover="@Intel(h.Game.Map.HiddenMobileStronghold)"
               OnClick="@(e => OnClick(e, h.Game.Map.HiddenMobileStronghold))" />

        @if (showHMS && h.Status.HighlightedTerritories.Contains(h.Game.Map.HiddenMobileStronghold.Territory))
        {
            <Circle X="(hmsCenter.X + 0.3f * Skin.Current.HmsRadius)" Y="hmsCenter.Y" Radius="(0.85f * Skin.Current.HmsRadius)"
                    FillColor="@Skin.Current.HIGHLIGHT_OVERLAY_COLOR" FillOpacity="1" StrokeColor="red" StrokeWidth="1" />
        }

        <Image X="@(hmsCenter.X - 0.4f * Skin.Current.HmsRadius + Math.Abs(Skin.Current.HmsDX))"
               Y="@(hmsCenter.Y - 0.18f * Skin.Current.HmsRadius)"
               Diameter="@(Skin.Current.FORCETOKEN_RADIUS)"
               Src="@(showHMS ? Skin.Current.Eye_URL : Skin.Current.EyeSlash_URL)"
               ShadowColor="black" ShadowX="1" ShadowY="1" ShadowBlur="0"
               OnClick="OnShowHmsClick"
               Title="@(showHMS ? "Hide HMS" : "Show HMS")" />

        int xOffset = 0;
        int yOffset = 0;
        var pos = Skin.Current.GetCenter(Game.Map.HiddenMobileStronghold);

        if (forceLocations.ContainsKey(Game.Map.HiddenMobileStronghold))
        {
            var battalions = forceLocations[Game.Map.HiddenMobileStronghold];
            int nrOfBattalions = battalions.Count;
            yOffset = -(nrOfBattalions - 1) * Skin.Current.FORCETOKEN_RADIUS;

            foreach (var battalion in battalions)
            {
                var player = Game.GetPlayer(battalion.Faction);
                var threatened = Game.ThreatenedByAllyPresence(player, Game.Map.HiddenMobileStronghold.Territory);

                xOffset = 0;
                if (battalion.AmountOfForces > 0)
                {
                    <MapForce X=@pos.X Y=@(yOffset + pos.Y) Special=@false Amount=@battalion.AmountOfForces Faction=@battalion.Faction Threatened=@threatened ShowPopover="false" />
                    xOffset += 2 * Skin.Current.FORCETOKEN_RADIUS;
                }

                if (battalion.AmountOfSpecialForces > 0)
                {
                    <MapForce X=@(pos.X + xOffset) Y=@(yOffset + pos.Y) Special=@true Amount=@battalion.AmountOfSpecialForces Faction=@battalion.Faction Threatened=@threatened ShowPopover="false" />
                    xOffset += 2 * Skin.Current.FORCETOKEN_RADIUS;
                }

                yOffset += 2 * Skin.Current.FORCETOKEN_RADIUS;
            }
        }

        xOffset = 0;
        foreach (var hero in Game.LeaderState.Where(state => state.Key is IHero && state.Value.Alive && state.Value.CurrentTerritory == Game.Map.HiddenMobileStronghold.Territory).Select(state => state.Key))
        {
            <MapLeader h="h" ToShow="hero" X=@(pos.X + xOffset - Skin.Current.FORCETOKEN_RADIUS) Y=@(yOffset + pos.Y - Skin.Current.FORCETOKEN_RADIUS) Diameter="@(3 * Skin.Current.FORCETOKEN_RADIUS)" />
            xOffset += 3 * Skin.Current.FORCETOKEN_RADIUS;
        }
    }

}

@code {

    private Situation situation = new();
    protected override bool ShouldRender() => CheckAndResetDirty() || situation.RequiresUpdate(Game);

    private bool showHMS = true;
    private bool dirty = false;

    [Parameter]
    public EventCallback<LocationEventArgs> OnLocationClick { get; set; }

    private async Task OnClick(MouseEventArgs e, Location l)
    {
        await OnLocationClick.InvokeAsync(new LocationEventArgs() { Location = l, AltKey = e.AltKey, CtrlKey = e.CtrlKey, ShiftKey = e.ShiftKey });
    }

    private bool CheckAndResetDirty()
    {
        bool result = dirty;
        dirty = false;
        return result;
    }

    private void OnShowHmsClick(MouseEventArgs e)
    {
        showHMS = !showHMS;
        dirty = true;
        StateHasChanged();
    }
}