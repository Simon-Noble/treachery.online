<!--
 * Copyright 2020-2021 Ronald Ossendrijver. All rights reserved.
--->

@using Treachery.Shared
@using Treachery.Client.GenericComponents;
@inherits GameEventComponent<EstablishPlayers>

<GameEventComponentLayout IsUrgent="@IsUrgent" BackgroundStyle="@BackgroundStyle" HeaderStyle="@HeaderStyle" BodyStyle="@BodyStyle" @bind-Collapsed="@Collapsed">

    <Header>You may now configure your game below.</Header>
    <Body>

        <CheckboxComponent @bind-Value="info.HostParticipates">The host (you) will participate in this game</CheckboxComponent>

        <div class="mt-2"><strong>Players:</strong> @string.Join(", ", Players)</div>

        <SelectNumberComponent Disabled="@Readonly" @bind-Value="info.MaximumNumberOfTurns" Min="1" Max="EstablishPlayers.GetMaximumNumberOfTurns()" Label="Maximum number of turns"/>

        <SelectNumberComponent Disabled="@Readonly" @bind-Value="info.MaximumNumberOfPlayers" Min="1" Max="EstablishPlayers.GetMaximumNumberOfPlayers()" Label="Maximum number of players"/>

        <SelectFactionComponent Disabled="@Readonly" Selected="info.FactionsInPlay" Values="EstablishPlayers.AvailableFactions()" OnChanged="StateHasChanged">
            <Label>Factions in play</Label>
        </SelectFactionComponent>

        <label class="mt-1 mb-0">AI Players</label>
        @foreach (var rule in Game.GetRulesInGroup(RuleGroup.Bots))
        {
            <ChecklistItemComponent Disabled="@Readonly" Value="@rule" Values="info.Rules" Callback="StateHasChanged" />
        }

        <SelectComponent Disabled="@Readonly" @bind-Value="@Ruleset" Values="Rulesets">
            <Label>Rules</Label>
        </SelectComponent>

        <ButtonRowComponent Confirm="StartNewOrLoadedGame" ConfirmText="@StartButtonLabel" ConfirmError="@Validation" />

        @if (h.Host.LoadedGame == null)
        {
            <div class="text-info mt-2 mb-1">You can enable or disable individual rules below.</div>
        }

        @foreach (var rulegroup in RuleGroups)
        {
            if (Game.GetRulesInGroup(rulegroup).Any())
            {
                <label class="mt-1 mb-0">@Skin.Current.Describe(rulegroup)</label>
                @foreach (var rule in Game.GetRulesInGroup(rulegroup))
                {
                    @if (IsNew(rule))
                    {
                        <ChecklistItemComponent Disabled="@Readonly" Value="@rule" Values="info.Rules">
                            <span class="badge badge-info">new!</span>
                        </ChecklistItemComponent>
                    }
                    else
                    {
                        <ChecklistItemComponent Disabled="@Readonly" Value="@rule" Values="info.Rules" />
                    }
                }
            }
        }

    </Body>

</GameEventComponentLayout>

@code {

    protected override bool IsUrgent => true;

    private GameInfo info => h.Host.GameBeingEstablished;

    private Ruleset Ruleset
    {
        get
        {
            return info.Ruleset;
        }
        set
        {
            info.Ruleset = value;
            RulesetChanged(value);
        }
    }

    private void RulesetChanged(Ruleset ruleset)
    {
        var botRules = info.Rules.Where(r => Game.GetRuleGroup(r) == RuleGroup.Bots).ToArray();

        info.Rules.Clear();
        info.Rules.AddRange(botRules);

        if (Game.RulesetDefinition.ContainsKey(info.Ruleset))
        {
            info.Rules.AddRange(Game.RulesetDefinition[info.Ruleset]);
        }

        StateHasChanged();
    }

    private async Task StartNewOrLoadedGame()
    {
        var skinData = Skin.Current == Skin.Dune1979 ? "" : Skin.SkinToString(Skin.Current);
        if (h.Host.LoadedGame != null)
        {
            await h.Host.LoadGameAndSkin(h.Host.LoadedGameData, h.Host.LoadedGame, skinData);
        }
        else
        {
            await base.Confirm();
            if (skinData != "")
            {
                await h.Host.LoadSkin(skinData);
            }
        }
    }

    protected override void OnParametersSet()
    {
        if (h.Host.LoadedGame != null)
        {
            info.Ruleset = h.Host.LoadedGame.Ruleset;
            info.MaximumNumberOfPlayers = h.Host.LoadedGame.MaximumNumberOfPlayers;
            info.MaximumNumberOfTurns = h.Host.LoadedGame.MaximumNumberOfTurns;
            info.Rules = h.Host.LoadedGame.AllRules.ToList();
            info.Ruleset = h.Host.LoadedGame.Ruleset;
            info.FactionsInPlay = h.Host.LoadedGame.Players.Select(p => p.Faction).ToList();
        }
    }

    protected override EstablishPlayers ConfirmedResult
    {
        get
        {
            return new EstablishPlayers(Game)
            {
                GameName = string.Format("{0}'s Game", h.PlayerName),
                Seed = new Random().Next(),
                Players = Players,
                MaximumTurns = info.MaximumNumberOfTurns,
                MaximumNumberOfPlayers = info.MaximumNumberOfPlayers,
                ApplicableRules = info.Rules.ToArray(),
                FactionsInPlay = info.FactionsInPlay
            };
        }
    }

    private IEnumerable<string> Players => h.Host.JoinedPlayers.Where(p => info.HostParticipates || p != h.PlayerName);

    private IEnumerable<Ruleset> Rulesets => EstablishPlayers.AvailableRulesets();

    private IEnumerable<RuleGroup> RuleGroups => EstablishPlayers.AvailableRuleGroups();

    private string StyleDef(Faction f) => string.Format("background-color:{0}", Skin.Current.GetFactionColorTransparant(f));

    private bool Readonly => h.Host.LoadedGame != null;

    private string StartButtonLabel => string.Format("{0} Game!", h.Host.LoadedGame == null ? "Start" : "Continue");

    private bool IsNew(Rule rule) => false; // rule == Rule.CustomDecks || rule == Rule.DisableEndOfGameReport;
}
